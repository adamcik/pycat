#! /usr/bin/python
# Copyright (c) 2010 Thomas Kongevold Adamcik
# Released under MIT license, see COPYING file

import logging
import re
import select
import socket
import subprocess
import sys
import time

from optparse import OptionParser, OptionValueError

try:
    from ircbot import SingleServerIRCBot, ServerConnectionError, \
            parse_channel_modes, nm_to_n as get_nick
    from irclib import VERSION as IRCLIB_VERSION
except ImportError:
    print 'irclib required for bot work'
    sys.exit(1)

LOG_FORMAT = "[%(name)8s %(asctime)s] %(message)s"
logging.basicConfig(level=logging.DEBUG, format=LOG_FORMAT)

IRCLIB_SUPPORTS_IPV6 = (IRCLIB_VERSION[0] >= 0 and
        IRCLIB_VERSION[1] >= 4 and IRCLIB_VERSION[2] >= 7)

class PyCatBot(SingleServerIRCBot):
    def __init__(self, server_list, nick, real, channel,
                 listen_addr=None, script=None):

        SingleServerIRCBot.__init__(self, server_list, nick, real,
                                    reconnection_interval=30)
        self.channel = channel
        self.script = script
        self.listen_addr = listen_addr

        self.recivers = []
        self.processes_stdout = []
        self.processes_stderr = []
        self.recv_buffers = {}
        self.send_buffer = []
        self.loggers = {}

        self.listener = None

        self.last_send = time.time()
        self.last_recv = time.time()
        self.send_frequency = 2.5
        self.send_scheduled = False

        self.setup_logging()
        self.setup_throttling()
        self.setup_listener()

        self.running = False

    def setup_logging(self):
        self.loggers['main'] = logging.getLogger('main')
        self.loggers['irc'] = logging.getLogger('irc')
        self.loggers['process'] = logging.getLogger('process')
        self.loggers['listener'] = logging.getLogger('listener')
        self.loggers['reciver'] = logging.getLogger('reciver')

        def logger(conn, event):
            args = map(self.decode, event.arguments())
            self.loggers['irc'].debug(' '.join(args))

        self.connection.add_global_handler('all_raw_messages', logger)

    def setup_throttling(self):
        orignial_send_raw = self.connection.send_raw

        def send_raw(string):
            self.loggers['irc'].debug(string.decode('utf-8'))
            self.last_send = time.time()
            orignial_send_raw(string)

        def handle_send_buffer():
            since_last = time.time() - self.last_send

            if not self.send_buffer:
                return
            elif since_last < self.send_frequency:
                delay = self.send_frequency - since_last
                self.send_scheduled = True
                self.connection.execute_delayed(delay, handle_send_buffer)
                return

            string = self.send_buffer.pop(0)

            send_raw(string)

            if self.send_buffer:
                self.send_scheduled = True
                self.connection.execute_delayed(self.send_frequency,
                    handle_send_buffer)
            else:
                self.send_scheduled = False

        def throttling(string):
            if not re.match('^(PRIVMSG|NOTICE)', string):
                send_raw(string)
                return

            self.send_buffer.append(string)

            if not self.send_scheduled:
                handle_send_buffer()

        self.connection.send_raw = throttling

    def setup_listener(self):
        if not self.listen_addr:
            return

        try:
            listener = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            listener.setblocking(0)
            listener.bind(self.listen_addr)
            listener.listen(5)

            self.listener = listener
        except socket.gaierror, e:
            self.loggers['listener'].error('Could not setup listener: %s', e)

    def _connect(self):
        server = self.server_list[0][0]
        port = self.server_list[0][1]

        try:
            ip = socket.getaddrinfo(server, 0, socket.AF_UNSPEC,
                    socket.SOCK_STREAM)[0][4][0]
        except socket.gaierror, e:
            self.loggers['irc'].error('getaddrinfo for %s failed', server)
            return False

        if '.' in ip:
            ip = '::FFFF:' + ip

        self.loggers['irc'].info('Trying to connect to %s [%s]:%s',
            server, ip, port)

        kwargs = {'ircname': self._realname}

        if IRCLIB_SUPPORTS_IPV6:
            kwargs['ipv6'] = True

        try:
            self.connect(ip, port, self._nickname, **kwargs)
        except ServerConnectionError:
            self.loggers['irc'].error('Failed to connect to %s [%s]:%s',
                server, ip, port)
            return False

        return True

    def on_welcome(self, conn, event):
        conn.join(self.channel)

    def on_disconnect(self, conn, event):
        self.send_buffer = []

    def on_nicknameinuse(self, conn, event):
        conn.nick(conn.get_nickname() + '_')

    def on_invite(self, conn, event):
        if event.arguments()[0] == self.channel:
            conn.join(self.channel)

    def on_mode(self, conn, event):
        if event.target() != self.channel:
            return

        nick = conn.get_nickname()
        modes = parse_channel_modes(' '.join(event.arguments()))

        if ['+', 'o', nick] in modes:
            conn.mode(self.channel, '+v-o %s %s' % (nick, nick))

    def on_pubmsg(self, conn, event):
        if not self.script:
            return

        nick = conn.get_nickname()
        channel = event.target()
        source= get_nick(event.source())
        message = self.decode(event.arguments()[0])

        try:
            p = subprocess.Popen([self.script, nick, channel, source, message],
                bufsize=4096, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.processes_stdout.append(p.stdout)
            self.processes_stderr.append(p.stderr)
        except OSError, e:
            self.loggers['process'].error('Could not start process: %s', e)

    def on_privmsg(self, conn, event):
        self.on_pubmsg(conn, event)

    def on_erroneusnickname(self, conn, event):
        nick = self.decode(event.arguments()[0])
        self.loggers['main'].error("Invalid nickname '%s', stopping bot.", nick)
        self.running = False

    def start(self):
        if not self._connect():
            self._connected_checker()

        self.running = True

        while self.running:
            sockets = self.processes_stdout + \
                self.processes_stderr + self.recivers

            if self.listener:
                sockets.append(self.listener)

            if self.connection.socket:
                sockets.append(self.connection.socket)

            self.process_sockets(sockets)

    def stop(self):
        if self.connection.is_connected():
            self.connection.disconnect('...')

        if self.listener:
            self.listener.close()

        for sock in self.recivers + self.processes_stdout + self.processes_stderr:
            sock.close()

    def process_sockets(self, sockets):
        for sock in select.select(sockets, [], [], 0.2)[0]:
            if sock in self.recivers:
                self.handle_reciver(sock)
            elif sock is self.listener:
                self.handle_listener(sock)
            elif sock in self.processes_stdout:
                self.handle_stdout(sock)
            elif sock in self.processes_stderr:
                self.handle_stderr(sock)
            else:
                self.handle_irc(sock)

        self.handle_timeout()

    def handle_reciver(self, sock):
        peer = sock.getpeername()[0]
        debug = self.loggers['reciver'].debug

        reader = lambda: sock.recv(4096)
        plain_logger = lambda m: debug('%s %s', peer, m)
        close_logger = lambda: debug('%s disconnected', peer)

        self.handle_generic(sock, reader, self.recivers, plain_logger,
            close_logger)

    def handle_stdout(self, sock):
        reader = lambda: sock.read(4096)
        plain_logger = lambda m: self.loggers['process'].debug(m)

        self.handle_generic(sock, reader, self.processes_stdout, plain_logger)

    def handle_stderr(self, sock):
        data = sock.read(4096)

        if len(data) == 0:
            self.processes_stderr.remove(sock)
            sock.close()
            return

        self.loggers['process'].error(data)

    def handle_generic(self, sock, reader, sockets, plain_logger=None,
            close_logger=None):

        if sock not in self.recv_buffers:
            self.recv_buffers[sock] = u''

        data = reader()

        if len(data) == 0:
            if close_logger:
                close_logger()
            sockets.remove(sock)
            sock.close()
        else:
            self.recv_buffers[sock] += self.decode(data)

        while '\n' in self.recv_buffers[sock]:
            message, trailing = self.recv_buffers[sock].split('\n', 1)
            self.recv_buffers[sock] = trailing

            if plain_logger:
                plain_logger(message)
            self.send_message(message)

        if len(data) == 0:
            del self.recv_buffers[sock]

    def send_message(self, message):
        if not message.strip():
            return
        elif self.channel not in self.channels:
            self.loggers['irc'].warning('Bot not in channel, discarding message: %s',
                message)
            return

        message = message.encode('utf-8')
        users = self.channels[self.channel].users()
        targets = [self.channel]

        if '@' in message.split(' ', 1)[0]:
            parts = message.split(' ')

            targets = parts.pop(0)
            targets = targets.split(',')
            targets = map(lambda t: t.lstrip('@'), targets)

            message = ' '.join(parts)

        if not message.strip():
            self.loggers['irc'].warning('Discarding empty message to: %s',
                ','.join(targets))
            return

        def clean(target):
            if target != self.channel and target not in users:
                self.loggers['irc'].warning('%s not known, discarding message: %s',
                    target, message.decode('utf-8'))
                return False
            return True

        targets = filter(clean, targets)

        if message.startswith('/me '):
            for target in targets:
                self.connection.action(target, message[len('/me '):])
        elif message.startswith('/notice '):
            for target in targets:
                self.connection.notice(target, message[len('/notice '):])
        else:
            self.connection.privmsg_many(targets, message)

    def handle_listener(self, sock):
        conn, addr = sock.accept()
        self.loggers['reciver'].debug('%s connected', addr[0])
        self.recivers.append(conn)

    def handle_irc(self, sock):
        self.ircobj.process_data([sock])
        self.last_recv = time.time()

    def handle_timeout(self):
        self.ircobj.process_timeout()

    def decode(self, data):
        try:
            data = data.decode('utf-8')
        except UnicodeDecodeError:
            data = data.decode('iso-8859-1')
        return data

def main():
    usage = '''Usage: %prog server[:port][,server[:port]] nickname channel [options]

Examples:
  Connect to irc.efnet.net, with nick cat, name 'Majo nes', script /foo/bar:
    %prog irc.efnet.net cat efnet --realname='Majo Nes' --script=/foo/bar
  Use fallbacks on IRCnet, nick cat, channel pycat, listen on port 80 on all interfaces:
    %prog irc.hitos.no,irc.pvv.org:6668 cat '#pycat' --listen=:80'''

    parser = OptionParser(usage=usage)
    parser.add_option('--listen', metavar='[addr]:port',
        help='address to bind listener to')
    parser.add_option('--realname', metavar='name',
        help='realname to provide to IRC server')
    parser.add_option('--script', metavar='path',
        help='script to send messages to')

    (options, args) = parser.parse_args()

    if len(args) != 3:
        parser.print_help()
        sys.exit(0)

    servers, nickname, channel = args

    if not channel.startswith('#'):
        channel = '#' + channel

    server_list = []

    for addr in servers.split(','):
        if addr and ':' in addr:
            host, port = addr.split(':', 1)
            try:
                server_list.append((host, int(port)))
            except ValueError:
                parser.error('server argument got an invalid port number')
        else:
            server_list.append((addr, 6667))

    if options.listen and ':' in options.listen:
        host, port = options.listen.split(':', 1)
        try:
            listen = (host, int(port))
        except ValueError:
            parser.error('--listen got an invalid port number')
    else:
        listen = None

    pycat = PyCatBot(server_list, nickname, options.realname or nickname, channel,
        listen, options.script)

    try:
        pycat.start()
    except KeyboardInterrupt:
        pass

    pycat.stop()

if __name__ == '__main__':
    main()
