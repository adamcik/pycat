#! /usr/bin/python
# Copyright (c) 2010 Thomas Kongevold Adamcik
# Released under MIT license, see COPYING file

import logging
import os
import re
import select
import signal
import socket
import subprocess
import sys
import time

from optparse import OptionParser, OptionValueError

from ircbot import SingleServerIRCBot, ServerConnectionError, \
        parse_channel_modes, nm_to_n as get_nick

LOG_FORMAT = "[%(asctime)s] %(message)s"
logging.basicConfig(level=logging.DEBUG, format=LOG_FORMAT)

class PyCatBot(SingleServerIRCBot):
    def __init__(self, server_list, nick, real, channel,
                 listen_addr=None, script=None):

        SingleServerIRCBot.__init__(self, server_list, nick, real,
                                    reconnection_interval=30)
        self.channel = channel
        self.script = script
        self.listen_addr = listen_addr

        self.dispatchers = {}
        self.recv_buffers = {}
        self.send_buffer = []

        self.last_send = time.time()
        self.last_recv = time.time()
        self.send_frequency = 2.5
        self.send_scheduled = False

        self.setup_logging()
        self.setup_throttling()
        self.setup_listener()

        self.running = False

    def setup_logging(self):
        def debug_logger(conn, event):
            args = map(self.decode, event.arguments())
            logging.debug(' '.join(args))

        self.connection.add_global_handler('all_raw_messages', debug_logger)

    def setup_throttling(self):
        orignial_send_raw = self.connection.send_raw

        def send_raw(string):
            logging.debug(string.decode('utf-8'))
            self.last_send = time.time()
            orignial_send_raw(string)

        def handle_send_buffer():
            since_last = time.time() - self.last_send

            if not self.send_buffer:
                return
            elif since_last < self.send_frequency:
                delay = self.send_frequency - since_last
                self.send_scheduled = True
                self.connection.execute_delayed(delay, handle_send_buffer)
                return

            string = self.send_buffer.pop(0)

            send_raw(string)

            if self.send_buffer:
                self.send_scheduled = True
                self.connection.execute_delayed(self.send_frequency,
                    handle_send_buffer)
            else:
                self.send_scheduled = False

        def throttling(string):
            if not re.match('^(PRIVMSG|NOTICE)', string):
                send_raw(string)
                return

            self.send_buffer.append(string)

            if not self.send_scheduled:
                handle_send_buffer()

        self.connection.send_raw = throttling

    def setup_listener(self):
        if not self.listen_addr:
            logging.debug('No listener, stopping listener setup')
            return

        try:
            listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            listener.setblocking(0)
            listener.bind(self.listen_addr)
            listener.listen(5)

            logging.info('Listener set up on %s:%s' % self.listen_addr)

            self.dispatchers[listener] = self.handle_listener

        except socket.gaierror, e:
            logging.error('Could not setup listener: %s', e)

    def _connect(self):
        server = self.server_list[0][0]
        port = self.server_list[0][1]

        logging.info('Trying to connect to %s:%s', server, port)

        try:
            self.connect(server, port, self._nickname, ircname=self._realname)
            self.dispatchers[self.connection.socket] = self.handle_irc
        except ServerConnectionError:
            logging.error('Failed to connect to %s:%s', server, port)
            return False

        return True

    def on_welcome(self, conn, event):
        conn.join(self.channel)

    def on_disconnect(self, conn, event):
        self.send_buffer = []

    def on_nicknameinuse(self, conn, event):
        conn.nick(conn.get_nickname() + '_')

    def on_invite(self, conn, event):
        if event.arguments()[0] == self.channel:
            conn.join(self.channel)

    def on_mode(self, conn, event):
        if event.target() != self.channel:
            return

        nick = conn.get_nickname()
        modes = parse_channel_modes(' '.join(event.arguments()))

        if ['+', 'o', nick] in modes:
            conn.mode(self.channel, '+v-o %s %s' % (nick, nick))

    def on_pubmsg(self, conn, event):
        if not self.script:
            return

        nick = conn.get_nickname()
        target = event.target()
        source= get_nick(event.source())
        message = self.decode(event.arguments()[0])

        try:
            process = subprocess.Popen([self.script, nick, target, source, message],
                bufsize=4096, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        except OSError, e:
            logging.error('Could not start process: %s', e)
            return

        if nick == target:
            context = source
        else:
            context = target

        self.dispatchers[process.stdout] = lambda s: self.handle_stdout(s, context)
        self.dispatchers[process.stderr] = self.handle_stderr

        self.connection.execute_delayed(30, self.handle_hanging_process, [process])

    def on_privmsg(self, conn, event):
        self.on_pubmsg(conn, event)

    def on_erroneusnickname(self, conn, event):
        nick = self.decode(event.arguments()[0])
        logging.error("Invalid nickname '%s', stopping bot.", nick)
        self.running = False

    def on_badchanmask(self, conn, event):
        channel = self.decode(event.arguments()[0])
        logging.error("Invalid channel '%s', stopping bot.", channel)
        self.running = False

    def start(self):
        if not self._connect():
            self._connected_checker()

        self.running = True

        while self.running:
            sockets = self.dispatchers.keys()

            for sock in select.select(sockets, [], [], 0.2)[0]:
                self.dispatchers[sock](sock)

            self.handle_timeout()

    def stop(self):
        if self.connection.is_connected():
            self.connection.disconnect('...')

        for sock in self.dispatchers.keys():
            sock.close()
            del self.dispatchers[sock]

    def handle_reciver(self, sock):
        peer = sock.getpeername()[0]
        debug = logging.debug

        reader = lambda: sock.recv(4096)
        plain_logger = lambda m: debug('%s %s', peer, m)
        close_logger = lambda: debug('%s disconnected', peer)

        allowed_targets = [self.channel]
        allowed_targets.extend(self.channels[self.channel].users())

        self.handle_generic(sock, reader, allowed_targets,
            plain_logger, close_logger)

    def handle_stdout(self, sock, context):
        reader = lambda: sock.read(4096)
        plain_logger = lambda m: logging.debug(m)
        allowed_targets = [context]

        self.handle_generic(sock, reader, allowed_targets, plain_logger)

    def handle_stderr(self, sock):
        data = sock.read(4096)

        if len(data) == 0:
            del self.dispatchers[sock]
            sock.close()
            return

        logging.error(data)

    def handle_hanging_process(self, process):
        if process.poll() is None:
            logging.error('%s pid:%s taking to long, sending SIGTERM',
                self.script, process.pid)
            os.kill(process.pid, signal.SIGTERM)

    def handle_generic(self, sock, reader, allowed_targets,
            plain_logger=None, close_logger=None):

        if sock not in self.recv_buffers:
            self.recv_buffers[sock] = u''

        data = reader()

        if len(data) == 0:
            if close_logger:
                close_logger()

            del self.dispatchers[sock]

            sock.close()
        else:
            self.recv_buffers[sock] += self.decode(data)

        while '\n' in self.recv_buffers[sock]:
            message, trailing = self.recv_buffers[sock].split('\n', 1)
            self.recv_buffers[sock] = trailing

            if plain_logger:
                plain_logger(message)
            self.send_message(message, allowed_targets)

        if len(data) == 0:
            del self.recv_buffers[sock]

    def send_message(self, message, allowed_targets):
        if not message.strip():
            return
        elif self.channel not in self.channels:
            logging.warning('Bot not in channel, discarding message: %s',
                message)
            return

        message = message.encode('utf-8')
        targets = [self.channel]
        first = (message+' ').split(' ', 1)[0]

        if len(allowed_targets) > 1 and ('@' in first or '#' in first):
            targets = first.split(',')
            targets = map(lambda t: t.lstrip('@'), targets)
            message = (message+' ').split(' ', 1)[1]

        def clean(target):
            if target not in allowed_targets:
                logging.warning('Sending to %s not allowed, discarding message: %s',
                    target, message.decode('utf-8'))
                return False
            return True

        targets = filter(clean, targets)

        if not targets:
            pass
        elif not message.strip():
            logging.warning('Discarding empty message to: %s',
                ','.join(targets))
        elif message.startswith('/me '):
            for target in targets:
                self.connection.action(target, message[len('/me '):])
        elif message.startswith('/notice '):
            for target in targets:
                self.connection.notice(target, message[len('/notice '):])
        else:
            self.connection.privmsg_many(targets, message)

    def handle_listener(self, sock):
        conn, addr = sock.accept()
        logging.debug('%s connected', addr[0])

        if self.connection.is_connected():
            self.dispatchers[conn] = self.handle_reciver
        else:
            logging.warning('%s disconnected as irc is down', addr[0])
            conn.close()

    def handle_irc(self, sock):
        self.ircobj.process_data([sock])
        self.last_recv = time.time()

    def handle_timeout(self):
        self.ircobj.process_timeout()

    def decode(self, data):
        try:
            data = data.decode('utf-8')
        except UnicodeDecodeError:
            data = data.decode('iso-8859-1')
        return data

def main():
    usage = '''Usage: %prog server[:port][,server[:port]] nickname channel [options]

Examples:
  Connect to irc.efnet.net, with nick cat, name 'Majo nes', script /foo/bar:
    %prog irc.efnet.net cat efnet --realname='Majo Nes' --script=/foo/bar
  Use multiple fallbacks on IRCnet, nick cat, channel pycat
    %prog irc.ifi.uio.no,irc.hitos.no,irc.pvv.org:6668 cat '#pycat'
  Connect to irc.freenode.net, listen on port 8000 on a specific interface:
    %prog irc.freenode.net cat '#pycat' --listen=example.com:8000'''

    parser = OptionParser(usage=usage)
    parser.add_option('--listen', metavar='[addr]:port',
        help='address to bind listener to')
    parser.add_option('--realname', metavar='name',
        help='realname to provide to IRC server')
    parser.add_option('--script', metavar='path',
        help='script to send messages to')

    (options, args) = parser.parse_args()

    if len(args) != 3:
        parser.print_help()
        sys.exit(0)

    servers, nickname, channel = args

    if not channel.startswith('#'):
        channel = '#' + channel

    server_list = []

    for addr in servers.split(','):
        if addr and ':' in addr:
            host, port = addr.split(':', 1)
            try:
                server_list.append((host, int(port)))
            except ValueError:
                parser.error('server argument got an invalid port number')
        else:
            server_list.append((addr, 6667))

    if options.listen and ':' in options.listen:
        host, port = options.listen.split(':', 1)
        try:
            listen = (host, int(port))
        except ValueError:
            parser.error('--listen got an invalid port number')
    else:
        listen = None

    pycat = PyCatBot(server_list, nickname, options.realname or nickname, channel,
        listen, options.script)

    try:
        pycat.start()
    except KeyboardInterrupt:
        pass

    pycat.stop()

if __name__ == '__main__':
    main()
