#! /usr/bin/python
# Copyright (c) 2010 Thomas Kongevold Adamcik
# Released under MIT license, see COPYING file

import logging
import os
import re
import select
import signal
import socket
import subprocess
import sys
import time

from optparse import OptionParser, OptionValueError

from ircbot import SingleServerIRCBot, ServerConnectionError, \
        parse_channel_modes, nm_to_n as get_nick

LOG_FORMAT = "[%(asctime)s] %(message)s"

def decode(string):
    if type(string) is unicode or string is None:
        return string

    try:
        string = string.decode('utf-8')
    except UnicodeDecodeError:
        string = string.decode('iso-8859-1')
    return string

def encode(string):
    if type(string) is not unicode:
        return string

    return string.encode('utf-8')

class PyCatBot(SingleServerIRCBot):
    def __init__(self, server_list, nick, real, channel,
                 listen_addr=None, script=None, match=None):

        SingleServerIRCBot.__init__(self, server_list, nick, real,
                                    reconnection_interval=30)

        self.channel = decode(channel)
        self.script = decode(script)
        self.match_re = re.compile(decode(match))
        self.listen_addr = listen_addr

        self.dispatchers = {}
        self.recv_buffers = {}

        self.send_timer = None
        self.send_buffer = []

        self.setup_logging()
        self.setup_throttling()
        self.setup_listener()

        self.running = False

    def setup_logging(self):
        def debug_logger(conn, event):
            line = decode(event.arguments()[0])
            logging.debug(line)

        self.connection.add_global_handler('all_raw_messages', debug_logger)

    def setup_throttling(self):
        self.send_raw = self.connection.send_raw
        self.connection.send_raw = self.send_buffer.append

    def remove_throttling(self):
        self.connection.send_raw = self.send_raw

    def setup_listener(self):
        if not self.listen_addr:
            logging.debug('No listener, stopping listener setup')
            return

        try:
            listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            listener.setblocking(0)
            listener.bind(self.listen_addr)
            listener.listen(5)

            logging.info('Listener set up on %s:%s' % self.listen_addr)

            self.dispatchers[listener] = self.handle_listener

        except socket.gaierror, e:
            logging.error('Could not setup listener: %s', e)

    def get_version(self):
        return 'pycat by Thomas Adamcik - http://github.com/adamcik/pycat'

    def _connect(self):
        server = self.server_list[0][0]
        port = self.server_list[0][1]

        logging.info('Trying to connect to %s:%s', server, port)

        try:
            self.connect(server, port, self._nickname, ircname=self._realname)
            self.dispatchers[self.connection.socket] = self.handle_irc
        except ServerConnectionError:
            logging.error('Failed to connect to %s:%s', server, port)
            return False

        return True

    def on_welcome(self, conn, event):
        conn.join(encode(self.channel))

    def on_disconnect(self, conn, event):
        message = decode(event.arguments()[0])
        server = decode(event.source())
        logging.warning('Disconnected from %s: %s', server, message)

        for sock in self.dispatchers.keys():
            if self.dispatchers[sock] == self.handle_irc:
                del self.dispatchers[sock]

        self.send_buffer = []
        self.connection.send_raw = self.send_buffer.append

    def on_nicknameinuse(self, conn, event):
        nick = decode(conn.get_nickname() + '_')
        logging.warning('Changing nick to %s', nick)
        conn.nick(encode(nick))

    def on_invite(self, conn, event):
        if event.arguments()[0] == self.channel:
            nick = decode(get_nick(event.source()))
            logging.info('Joining %s due to invite from %s',
                self.channel, nick)
            conn.join(encode(self.channel))

    def on_mode(self, conn, event):
        if event.target() != self.channel:
            return

        nick = conn.get_nickname()
        modes = parse_channel_modes(' '.join(event.arguments()))

        if ['+', 'o', nick] in modes:
            logging.info('%s was oped, Voiceing and deoping', decode(nick))
            conn.mode(self.channel, '+v-o %s %s' % (nick, nick))

    def on_pubmsg(self, conn, event):
        if not self.script:
            return

        nick = decode(conn.get_nickname())
        target = decode(event.target())
        source= decode(get_nick(event.source()))
        message = decode(event.arguments()[0])

        if self.match_re and not self.match_re.match(message):
            return
        elif target == nick:
            return

        args = [self.script, nick, target, source, message]
        logging.info('Starting: %s %s %s %s %s', *args)
        args = map(encode, args)

        try:
            process = subprocess.Popen(args, bufsize=4096,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        except OSError, e:
            logging.error('Could not start process: %s', e)
            return

        if nick == target:
            context = source
        else:
            context = target

        self.dispatchers[process.stdout] = lambda s: self.handle_stdout(s, context)
        self.dispatchers[process.stderr] = self.handle_stderr

        self.connection.execute_delayed(30, self.handle_hanging_process, [process])

    def on_privmsg(self, conn, event):
        self.on_pubmsg(conn, event)

    def on_erroneusnickname(self, conn, event):
        nick = decode(event.arguments()[0])
        logging.critical("Invalid nickname '%s', stopping bot.", nick)
        self.running = False

    def on_badchanmask(self, conn, event):
        channel = decode(event.arguments()[0])
        logging.critical("Invalid channel '%s', stopping bot.", channel)
        self.running = False

    def start(self):
        if not self._connect():
            self._connected_checker()

        self.running = True

        while self.running:
            sockets = self.dispatchers.keys()

            for sock in select.select(sockets, [], [], 0.2)[0]:
                self.dispatchers[sock](sock)

            self.handle_timeout()

    def stop(self):
        self.remove_throttling()

        if self.connection.is_connected():
            self.connection.disconnect('...')

        for sock in self.dispatchers.keys():
            sock.close()
            del self.dispatchers[sock]

    def handle_reciver(self, sock):
        peer = sock.getpeername()[0]
        data = sock.recv(4096)

        for line in self.handle_data(sock, data):
            logging.debug('%s %s', peer, line)

            targets, message = self.parse_targets(line)
            self.send_message(message, targets)

        if len(data) == 0:
            logging.debug('%s disconnected', peer)

    def parse_targets(self, line):
        if encode(self.channel) not in self.channels:
            return [], message

        allowed_targets = self.channels[encode(self.channel)].users()
        allowed_targets = map(decode, allowed_targets)
        allowed_targets.append(self.channel)

        parts = line.split(' ')

        if len(parts) > 1 and ('@' in parts[0] or '#' in parts[0]):
            strip = lambda s: s.lstrip('@')
            allowed = lambda s: s in allowed_targets

            targets = parts.pop(0).split(',')
            targets = map(strip, targets)
            targets = filter(allowed, targets)
        else:
            targets = [self.channel]

        return targets, ' '.join(parts)

    def handle_stdout(self, sock, context):
        data = sock.read(4096)

        for line in self.handle_data(sock, data):
            logging.debug(line)
            self.send_message(line, [context])

    def handle_stderr(self, sock):
        data = sock.read(4096)

        for line in self.handle_data(sock, data):
            logging.error(line)

    def handle_data(self, sock, data):
        if sock not in self.recv_buffers:
            self.recv_buffers[sock] = u''

        self.recv_buffers[sock] += decode(data)

        while '\n' in self.recv_buffers[sock]:
            line, trailing = self.recv_buffers[sock].split('\n', 1)
            self.recv_buffers[sock] = trailing

            if line:
                yield line

        if len(data) == 0:
            line = self.recv_buffers[sock]

            del self.recv_buffers[sock]
            del self.dispatchers[sock]
            sock.close()

            if line:
                yield line

    def handle_hanging_process(self, process):
        if process.poll() is None:
            logging.error('%s pid:%s taking to long, sending SIGTERM',
                self.script, process.pid)
            os.kill(process.pid, signal.SIGTERM)

    def send_message(self, message, targets):
        encoded_targets = map(encode, targets)
        encoded_message = encode(message)

        if not message.strip():
            logging.warning('Discarding empty message to: %s',
                ','.join(targets))
        elif message.startswith('/me '):
            for target in encoded_targets:
                self.connection.action(target, encoded_message[len('/me '):])
        elif message.startswith('/notice '):
            for target in encoded_targets:
                self.connection.notice(target, encoded_message[len('/notice '):])
        else:
            self.connection.privmsg_many(map(encode, targets), encoded_message)

    def handle_listener(self, sock):
        conn, addr = sock.accept()
        logging.debug('%s connected', addr[0])

        if self.connection.is_connected():
            self.dispatchers[conn] = self.handle_reciver
        else:
            logging.warning('%s disconnected as irc is down', addr[0])
            conn.close()

    def handle_irc(self, sock):
        self.ircobj.process_data([sock])

    def handle_timeout(self):
        self.handle_send_buffer()
        self.ircobj.process_timeout()

    def handle_send_buffer(self):
        if not self.send_buffer:
            return

        if self.send_timer < time.time():
            self.send_timer = time.time()

        while self.send_timer < time.time() + 10 and self.send_buffer:
            self.send_timer += 2

            string = self.send_buffer.pop(0)
            logging.debug(decode(string))
            self.send_raw(string)

def main():
    usage = '''Usage: %prog server[:port][,server[:port]] nickname channel [options]

Examples:
  Connect to irc.efnet.net, with nick cat, name 'Majo nes', script /foo/bar:
    %prog irc.efnet.net cat efnet --realname='Majo Nes' --script=/foo/bar
  Use multiple fallbacks on IRCnet, nick cat, channel pycat
    %prog irc.ifi.uio.no,irc.hitos.no,irc.pvv.org:6668 cat '#pycat'
  Connect to irc.freenode.net, listen on port 8000 on a specific interface:
    %prog irc.freenode.net cat '#pycat' --listen=example.com:8000
  Connect to localhost, script /foo/bar and send messages that match ^!:
    %prog localhost cat '#pycat' --script=/foo/bar --match '^!' '''

    parser = OptionParser(usage=usage)
    parser.add_option('-d', '--debug',  action='store_const',
        dest='debug', const=logging.DEBUG, help='set log-level to debug')
    parser.add_option('--listen', metavar='[addr]:port',
        help='address to bind listener to')
    parser.add_option('--realname', metavar='name',
        help='realname to provide to IRC server')
    parser.add_option('--script', metavar='path',
        help='script to send messages to')
    parser.add_option('--match', metavar='regexp', default='.',
        help='regexp to limit messages sent to script')

    (options, args) = parser.parse_args()

    if len(args) != 3:
        parser.print_help()
        sys.exit(0)

    logging.basicConfig(level=options.debug or logging.INFO,
        format=LOG_FORMAT)

    servers, nickname, channel = args

    if not channel.startswith('#'):
        channel = '#' + channel

    server_list = []

    for addr in servers.split(','):
        if addr and ':' in addr:
            host, port = addr.split(':', 1)
            try:
                server_list.append((host, int(port)))
            except ValueError:
                parser.error('server argument got an invalid port number')
        else:
            server_list.append((addr, 6667))

    if options.listen and ':' in options.listen:
        host, port = options.listen.split(':', 1)
        try:
            listen = (host, int(port))
        except ValueError:
            parser.error('--listen got an invalid port number')
    else:
        listen = None

    pycat = PyCatBot(server_list, nickname, options.realname or nickname,
        channel, listen, options.script, options.match)

    try:
        pycat.start()
    except KeyboardInterrupt:
        pass

    pycat.stop()

if __name__ == '__main__':
    main()
